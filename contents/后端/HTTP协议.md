---
title: HTTP 协议
date: 2022-02-10 17:35:47
categories:
- 后端
tags:
- HTTP 协议
keywords:
- HTTP 协议
description:
images:
---
> 超文本传输协议（Hyper Text Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使开发和部署非常地直截了当。
<!-- more -->
### HTTP 1.0
为了提高系统的效率，HTTP 1.0 规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不记录请求。

然而，这种短连接的方式，也造成了一些性能上的缺陷，例如：网页加载中，要通过链接访问图片、JavaScript文件、CSS文件等内容时，每次请求都需要重新建立连接，每次连接只能传输相对应请求的内容，并且连接的建立和关闭又比较费时，这严重影响客户端和服务端的性能，导致网页加载比较慢。连接无法复用导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。

客户端是依据域名来向服务器建立连接，连接数越多，资源开销和整体延迟都会随之增大。因此，一般PC端浏览器会针对单个域名的 server 控制在6～8个连接，手机端的连接数则一般控制在4～6个。连接数有限，每个请求要在得到响应才算完成，因此在多个请求的情况下会出现：队头阻塞（Head of line blocking）。尤其，当有个请求出现问题导致响应时间很久，这将严重阻塞后面的请求，导致带宽无法被充分利用。

带宽和延迟也是影响网络请求的重要因素，在网络基础建设已经使得带宽得到极大的提升。当下，大部分时候发生的延迟，都在于响应速度。基于以上情况会发现，http1.0 缺陷在于连接无法复用和队头阻塞(Head of line blocking)


### HTTP 1.1
为了克服 HTTP 1.0 的缺陷，HTTP 1.1 支持持久连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。网页的多个资源请求和应答可以在一个连接中传输，但每个网页的请求和应答仍然需要使用各自的连接。HTTP 1.1 还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个请求过程所需要的时间。

在 HTTP 1.1，Request 和 Reponse 头新增 connection 字段，此字段的含义是当 client 和 server 通信时是否采用长连接。
在 HTTP 1.1 中，client 和 server 都是默认对方支持长连接的，如果不希望使用长连接，则需要在 Request 或 Reponse 的 header 中指明 connection 的值为 close 。只要 Request 或 Response 的 header 中包含了值为 close 的 connection，都表明不使用长连接，使用的tcp 连接在请求处理完毕后会断开，之后的请求就必须创建新的 tcp 连接了。

HTTP 1.1 提供了与身份认证、状态管理和 Cache缓存等机制相关的请求头和响应头字段，克服了 HTTP 1.0 的性能问题，扩展了 HTTP 1.0 功能。如：
- HTTP 1.1 支持只发送 header 信息，如果服务器认为客户端有权限请求服务器，则 Status Code 返回100，客户端接收到100才开始把请求 body 发送到服务器；如果 Status Code 返回 401，则说明客户端无权限，就可以不用发送请求 body 了，这一机制节约了带宽。

- 在 HTTP 1.0 中主要使用 heade 里的 If-Modified-Since、Expires 来做为缓存判断的标准，HTTP 1.1 则引入了更多的缓存控制策略，例如：Entity tag、If-Unmodified-Since、 If-Match、If-None-Match等更多可供选择的缓存头来控制缓存策略。

- 在 HTTP 1.1 中增加 Host 请求头字段，WEB浏览器可以使用主机头名来明确表示要访问服务器上的哪个WEB站点，实现了一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点。

- HTTP 1.1 的长连接，增加了 Connection 字段，例如，Connection 参数的值为 Keep-Alive 时，表示返回本次请求结果后保持连接；Connection 请求头的值为 close 时，表示返回本次请求结果后关闭连接。

- HTTP 1.0 不支持文件断点续传，RANGE:bytes 是 HTTP 1.1 新增字段，HTTP 1.0 每次传送文件都是从文件头开始，即0字节处开始。RANGE:bytes=XXXX表示要求服务器从文件XXXX字节处开始传送，通过改字段可以实现文件断点续传。

### HTTP 1.0 与 HTTP 1.1 的区别
HTTP 1.1 相较于 HTTP 1.0 协议的区别主要体现在：

- 支持长连接，减少连接建立和断开次数，并支持请求并发。

- 通过权限身份验证，减少不必要信息的传输，优化带宽。

- 新增多种错误状态响应码，细化对错误的管理。

- 新增缓存策略字段，灵活运用缓存策略减少网络消耗。

- 新增 HOST 域，一台服务器上可以存在多个虚拟主机，并且共享一个IP地址。

### HTTP2.0

HTTP 2.0 比之前的版本，在性能上有很大的提升，做了以下优化处理。

##### 多路复用 (Multiplexing)

在 HTTP 1.1 协议中虽然支持同时建立多个 TCP 连接以支持并发请求，但 TCP 连接的开销也限制了连接数量，超过限制数目的请求会被阻塞。而 HTTP 2.0 的“多路复用”特性允许同时通过单一的连接发起多重的“请求-响应”消息，HTTP/2 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息，并行地在同一个 TCP 连接上双向交换消息。

##### 新的二进制格式（Binary Format）
在 HTTP 1.x 协议中 start line、header、body的解析是基于文本的，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，而二进制则不同，只认0和1的组合。基于这种考虑 HTTP 2.0 的协议解析决定采用二进制格式，实现方便且健壮。

##### 二进制分帧
HTTP 2.0 在应用层和传输层之间增加一个二进制分帧层。在不改动 HTTP 1.x 的语义、方法、状态码、URI 以及首部字段的情况下, 解决了 HTTP 1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量。在二进制分帧层中， HTTP 2.0 会将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码，其中 HTTP 1.x 的头部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面。

在过去，HTTP 性能优化的关键并不在于高带宽，而是低延迟，TCP 连接会随着时间进行自我调谐，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动，由于这种原因，让原本就具有突发性和短时性的 HTTP 短连接变的十分低效。HTTP 2.0 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流，所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。

这种单连接多资源的方式，减少服务端的连接压力，内存占用更少，连接吞吐量更大，而且由于 TCP 连接的减少而使网络拥塞状况得以改善，同时慢启动时间的减少，使拥塞和丢包恢复速度更快。

##### 首部压缩（Header Compression）
在之前，HTTP请求和响应都是由状态行、请求/响应头部、消息主体三部分组成。一般而言，消息主体都会经过gzip压缩，或者本身传输的就是压缩过后的二进制文件，但状态行和头部却没有经过任何压缩，直接以纯文本传输，随着Web功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，并且有些不常变化的字段内容的传输，导致一些资源浪费。

为此 HTTP 2.0 使用了专门为首部压缩而设计的 HPACK 算法，将所有的 Header 字段建立成一张表，对表进行差量更新，减少流量消耗。

##### 服务端推送（Server Push）
在之前，当网页使用了许多资源：HTML、样式表、脚本、图片等等，浏览器从获取HTML开始，然后在解析和评估页面的时候，增量请求去获取更多的资源文件。服务器必须等待浏览器发起请求才传输相对应的资源，网络经常是空闲的和未充分使用的。

为了充分利用服务端性能，HTTP 2.0 引入了server push，服务器可以对客户端的一个请求发送多个响应，在浏览器明确地请求资源之前，将网页中所需的资源文件发送给客户端，免得客户端再次创建连接发送请求到服务器端获取，这样客户端可以直接从本地加载这些资源，不用再通过网络。

### HTTPS
HTTP 请求中的数据都是明文传输的，在传输的过程中存在很多风险，他人可以获知通信内容，拦截并篡改内容。SSL/TLS 协议，为解决这些风险，对 HTTP 协议传输的数据进行加密，从而就诞生了 HTTPS。


HTTPS 在传输数据之前需要客户端与服务端之间进行握手，在握手过程中将确定双方加密传输数据的密码信息，握手过程的简单描述如下：

1. 客户端：
```
- 发送支持的 SSL/TLS 协议版本
- 发送客户端生成的随机数c，后面参与“对话密钥”的生成
- 发送支持的加密算法
- 发送支持的压缩算法
```

2. 服务端：
```
- 确认使用的 SSL/TLS 协议版本，如果版本不一致则关闭加密通信
- 发送服务端生成随机数s，后面参与“对话密钥”的生成
- 发送确认使用的加密算法
- 发送确认压缩算法
- 发送服务器证书
```

3. 客户端：
```
- 验证证书的合法性，不合法则关闭加密通信
- 生成随机数 pre-master key，用服务器证书公钥进行加密后发送给服务端
- 编码改变通知，确认随后的信息都将用双方商定的加密方法和密钥发送
- 客户端握手结束通知，表示客户端的握手阶段已经结束。将前面发送的所有内容计算hash值，用来供服务器校验。
```
4. 服务端：
```
- 用私钥解密出 pre-master key，用随机数c、随机数s、pre-master key 采用商定的算法生成一个对称密钥
- 编码改变通知，确认随后的信息都将用双方商定的加密方法和密钥发送
- 服务器握手结束通知，表示服务器的握手阶段已经结束。将前面发送的所有内容计算hash值，用来供客户端校验。
```
5. 握手结束后，客户端与服务端将采用商定的加密算法和生成的对话密钥对传输内容进行加密、解密处理。
